[STYLE] All macros and constants in caps: MAX_BUFFER_SIZE, TRACKING_ID_PREFIX.

[STYLE] Struct names and typedef's in camelcase: GtkWidget, TrackingOrder.

[STYLE] Functions that operate on structs: gtk_widget_show(), tracking_order_process().

[TIP] Don't use global variables. They are evil.

[STYLE] Functions that shouldn't be called directly, or have obscure uses, or
        whatever must start with one or more underscores at the beginning:
        _refrobnicate_data_tables(), _destroy_cache().

[STYLE] Initialize variables in there declarations.

[LANG] String constant is an array of characters. The internal representation of
       a string has a null character '\0' at the end, so physical storage
       required is one more than the number of characters. 'strlen(s)' excludes
       terminal '\0'.

[LANG] External and static variables are initialized to zero by default.

[STYLE] Use 'const' to show that you are not going to change value, especially
        in functions parameters: int strlen(const char[])

[LANG] Precedence of '&&' is higher than that of '||'.

[TIP] Specify 'signed' or 'unsigned' if non-character data is to be stored
      in 'char' variables.

[LANG] Logical operations in C are 0 or 1. '!' operator inverts them.

[LANG] 'floats' are not automatically converted to 'double'.

[TIP] The main reason for using 'float' is to save storage in a large arrays.

[LANG] x = f() + g() C do not define which function will be evaluated first.
       It is the same for function arguments.

[LANG] Non-zero means true.

[STYLE] When there is no initialization and re-initialization prefer 'while'.

[STYLE] Irrelevant details could be buried in the functions. In this way the
        chance of unwanted interactions is minimized and the pieces may even
        be useful in other programs.

[TIP] Always limit C programs input with upper bound.

[TIP] C programs are flat so functions are visible to any part of the entire
      program. Make functions kind of private as declare them 'static'

[TIP] Stick to onion architecture - layer can "see" only first below it.

[TIP] The structure of the project is very important - it explains the
      visibility. Do not make tricks with compilation order and keep it
      consistent.

[LANG] Functions can't be defined within functions so we can't do real
       functional programming.

[LANG] For external and static variables, the initializer must be a constant
       expression; the initialization is done once, conceptually before the
       program begins execution. Same in Java.

[LANG] If there are fewer initializers for an array than the number specified,
       the missing elements will be zero for external, static, and automatic
       variables.

[TIP] Do increment as usual i = i + 1; and when function is correct make it
      prefix or postfix.

[TIP] You can't nest functions but if it is needed definition should be used:
      void reverse(char[] str) {
          void reverser(char[] str, int i, int len);
          reverser(str, 0, strlen(str));
      }
      void reverser(char[] str, int i, int len) {
          ...
      }

[STYLE] Use #include "foo.h" for your modules and #include <..> for external.

[TIP] Prefer this type of declaration int *i;
      Is a mnemonic - what i points to has type int.

[STYLE] The single most important rule when writing code is this: check the
        surrounding code and try to imitate it. As a maintainer it is dismaying
        to receive a patch that is obviously in a different coding style to the
        surrounding code. This is disrespectful, like someone tromping into a
        spotlessly-clean house with muddy shoes. So, whatever this document
        recommends, if there is already written code and you are patching it,
        keep its current style consistent even if it is not your favorite style.

[LANG]    (*ip)++  // to increment value that ip points to
       The parentheses are necessary; without them, the expression would
       increment 'ip' instead of what it points to, because unary operators
       like * and ++ associate right to left.

[LANG] In some cases it is better to look at &x as anonymous pointer rather
       than address of x. Example: void swap(&x, &y) or int* ip; ip = &a[0];

[TIP] It is common for functions to use passed pointer as "wire" to set
      values as function side-effect.

[LANG] &a[i] and a+i are identical: a+i is the address of the i-th element
       beyond a. a[i] C language converts it to *(a + i) - pointer and offset

[LANG] char s[]; and char *s; are equivalent. Prefer latter. When an array name
       is passed to a function, the function can at its convenience believe
       that it has been handed either an array or a pointer, and manipulate it
       accordingly.

[LANG] C guarantees that zero is never a valid address for data, so a return
       value of zero can be used to signal an abnormal event, in this case, no
       space. Pointers and integers are not interchangeable. Zero is the sole
       exception: the constant zero may be assigned to a pointer, and a pointer
       may be compared with the constant zero. Check pointer with NULL.

[LANG] External and static variables are initialized to zero be default.

[LANG] The main reason for using float is to save storage in large arrays.

[LANG] The input or output, regardless of where it originates ore where it goes to,
       is dealt with as stream of characters.

[LANG] In C, any assignment, is an expression and returns a value, which is the
       value of the left hand side after the assignment. That's why it is
       possible to write: while (*s++ = *t++) {;}, if s and t are pointers to
       string. At the end assignment will return '\0' (same as 0) and the cycle
       will exit.

[TIP] Programs should act intelligently when given zero-length input or to
      defend itself with assert()

[LANG] By definition, chars are just small integers, so char variables and
       constants are identical to ints in arithmetic expressions.

[TIP] Prefer small functions. With properly designed functions, it is possible
      to ignore how a job is done; knowing what is done is sufficient.

[TIP] C language is like a Latin - gives you the base everything else are rules,
      conventions, project structure, autotools magic and proper macros.

[LANG] Function definitions can appear in any order, and in one source file or
       several, although no function can be split between files.

[LANG] Since main is a function like any other, it may return a value to its
       caller, which is in effect the environment in which the program was
       executed. Typically, a return value of zero implies normal termination -
       NO ERRORS; non-zero values signal unusual or erroneous termination
       conditions - WITH ERRORS.

[LANG] int is the default return type.

[LANG] "Definition" refers to the place where the variable is created or
       assigned storage; "declaration" refers to places where the nature of the
       variable is stated but no storage is allocated.

[LANG] The first name in an enum has value 0, the next 1, and so on, unless
       explicit values are specified.

[TIP] When your build tool do compilation be sure that will recompile when
      an included file is changed.

[TIP] In pointer arithmetic look at the types as a size of memory.

[TIP] You can use pointer arithmetic only when have the starting point and
      a way to calculate offset.

[LANG] malloc() use stack in it's implementation so we have to apply free() in
       reverse order.

[LANG] *--p; decrements p before fetching the value that p points to.
       Examples:   *p++ = val;   /* push value onto stack */
                   val = *--p;   /* pop top of the stack into val */

[TRICK] The syntax a[i] is equivalent to *(a + i). Thus it is valid to say 5[a]
        to get at the 5th element of a.

[TIP] Pointer-arithmetic says that given a pointer p and an integer i, p + i the
      pointer p advanced by i * sizeof(*p) bytes

[TIP] The [] operator is defined on pointers, not arrays. In particular, it's
      defined in terms of pointer arithmetic and pointer dereference.

[TIP] A pointer is abstractly a tuple (start, length, offset) with the condition
      that 0 <= offset <= length. Pointer arithmetic is essentially lifted
      arithmetic on the offset, with the caveat that if the result of the
      operation violates the pointer condition, it is an undefined value.
      Dereferencing a pointer adds an additional constraint that offset < length.

[TIP] POSIX is a superset of the standard C library, and it's important to note
      that it defers to it. If C and POSIX is ever in conflict, C wins.

[TIP] Mocking is strongly connected with the ability of dependency injection.
      Here a technique from functional programming could be used - replace all
      changeable steps in a workflow with functions. During testing you can
      pass fake/mocked one.

[TIP] Header files are sometimes also an appropriate location for ​struct​
      definitions. If other parts ofthe program will make direct use of the
      ​struct​ fields, then the definition of that ​structnecessarily must appear
      in the header file. If that is not the case, it is better to hide the
      ​struct definition in a .​c​ file. A common practice is to use a ​typedef​
      statement in a header file todeclare a type for other parts of the
      program, and hide the definition of that type.

[TIP] Having a long ​main ​function indicates a lack of abstraction, meaning that
      your code has notbeen sufficiently split into logical, smaller functions.

[TIP]           int a[10][20];
                int *b[10];     // lazy initialization
      The definition of b only allocates 10 pointers and does not initialize
      them; initialization must be done explicitly, either statically or with
      code. The important advantage of the pointer array is that the rows of
      the array may be of different lengths.

[TIP] During development wishful thinking can be used.
      At the beginning of the file declare functions that you with to have
      and continue to work on the algorithm. In this way also compilation
      will be fast. When definitions are added or imported you can safely
      remove them.

[LANG] (*++argv)[0]; because [] binds tighter than * and ++, the parentheses
       are necessary. By the way **++argv; is an alternate valid form.

[LANG] In expressions '[]' is with highest priority following by '->'. After
       them are '++' and then '--', but for them keep in mind if they are used
       as prefix or postfix operators. At last is '*' but it has some kind of
       highest priority from '++' and '--' if they are used as postfix
       operators(e.g. *p++)

[TIP] In C language, structures can be viewed as an some kind of memory template
      or model. Using it you can easily find out its parts or save at particular
      place. Using it the memory becomes a city with documented infrastructure.

[TIP] Glue C program during compilation through include/header_file.h.

[TIP] If you constantly ask for a particular field in a struct automate access
      with a macro e.g. #define OFFSET(s) (((struct symtab *) s) -> s_offset)

[TIP] Structures saves the state of the program in an organized way.

[TIP] Start writing program(or it's fragments) as first define 'in structures'
      and 'out structures' then concentrate on actions.

[LANG] Struct declaration defines as a type.

[LANG] A structure declaration that is not followed by a list of variables
       reserves no storage; it merely describes a template or the shape of a
       structure.

[LANG] Structures may not be compared.

[LANG] The only legal operations on a structure are copying it or assigning to
       it as a unit, taking its address with &, and accessing its members. Copy
       and assignment include passing arguments to functions and returning
       values from functions as well.

[LANG] If you have to write functions to manipulate structure There are at
       least three possible approaches: pass components separately, pass an
       entire structure, or pass a pointer to it.

[TIP] If a large structure is to be passed to a function, it is generally more
      efficient to pass a pointer than to copy the whole structure.

[TIP] Always use '->' to access structure fields.

[LANG] Note that the typedef name doesn't become visible until the end of the
       declaration. If the structure contains a pointer to itself, you have use the
       struct version to refer to it:
               typedef struct node {
                   int data;
                   struct node *next; /* can't use just "node *next" here */
               } node;

[LANG] A typedef, in spite of the name, does not define a new type; it merely
       creates a new name for an existing type.

[LANG] It is common idiom to use both typedef and struct:
              typedef struct S {
                  int x;
              } S;        // same name as struct tag!
       This gives you the convenience of the more concise typedef name but still
       allows you to use the full struct name if you need.

[LANG]       typedef struct S {
                 int x;
             } S;
       Could be rewritten as:
             struct S {  // define the identifier S within the struct name space
                 int x;
             };
             typedef struct S S;
       Last line adds a type alias S in the global name space and thus allows
       you to just write:
             void f(S arg); // struct keyword no longer needed

[LANG]       struct foo {
                 int n;
             };
       The name 'foo' is a tag; it's meaningful only when it's immediately
       preceded by the struct keyword.

[LANG]       struct foo {
                 int n;
             };
       Giving the struct a name (i.e. struct foo) also enables you to provide
       forward declarations of the struct. So in some other file, you could
       write:
            struct foo;
            void doit(struct foo *ptr);
       without having to have access to the definition.

[LANG] The following code creates an anonymous struct with the alias MyStruct:
            typedef struct {
                int one;
                int two;
            } MyStruct;
       You can't refer it without the alias because you don't specify an
       identifier for the structure. Forward declaration also will not work:
            struct MyStruct; // forward declaration in another file fails

[LANG] Structure is a data type. You don't give values to a data type. You give
       values to instances of data types. Here is an example:
            struct my_struct {
                int id;
            } MyStruct_default = {3};
            typedef struct my_struct MyStruct;
            // then it is possible to initialize every instance
            MyStruct mInstance = MyStruct_default;

[LANG] The size of the array is completely determined at compile time.

[LANG] A sizeof can not be used in a #if line, because the preprocessor does not
       parse type names. But the expression in the #def ine is not evaluated by
       the preprocessor, so the code here is legal.

[TIP] To be testing/emulating/mocking easier use some of following techniques:
          - Pass around functions (and use partial application) - this is simple
            functional approach that will work unless you need to pass around
            too many parameters.
          - Use an "interpreter" pattern where the computation is written in an
            (embedded) domain specific language that describes what computations
            and what I/O needs to be done (without actually doing it). Then you
            can interpret the DSL differently in real and test mode.
          - Use pipelines for each workflow. Write a "Lego blocks" that could be
            combined in various ways.
          - During development plan not only production but also and testing
            workflow.

[TRICK] C treats strings as arrays of characters conventionally terminated by a
        marker. All following statements are equivalent:
             for (p = str; *p; p++)
             for (p = str; *p != '\0'; p++)
             for (p = str; *p != 0; p++)
             for (p = str; p[0] != '\0'; p++)

[LANG] Addition of two pointer is illegal but subtraction is not! If you want to
       calculate middle of a string using pointers:
             mid = (low + high) / 2         // WRONG
             mid = low + (high - low) / 2   // Correct

[TIP] When use pointer arithmetic you work with relative addresses so it is very
      important to set the beginning and then calculate offset to find the right
      place. Here is an example:
           for (p = keytab; p < keytab + NKEYS; p++) {...
      'keytab' is the first element in an array, so the pointer p should be set
      to point it. It follows that the last element address is the beginning
      plus the size of the array which forms offset: keytab + NKEYS

[TIP] When calculate space to save a new string do not forget to include in
      calculation '\0':
           (char *) malloc(strlen(s) + 1); // +1 for '\0'

[TIP] When write a function that do some operation on a structure always as
      first argument pass the structure:
          struct tnode *addtree(struct tnode *p, char *s)
      this is the convention in many functional languages.

[TIP]     struct tnode {
              char *word;
              int count;
              struct tnode *left;   // pointer to the left
              struct tnode *right;
          };
      Tree is recursive structure that's why tnode is a tree
      and tree is tnode. In this way you can pass a tree and
      the function could return "grown tree" e.g
          struct tnode *root;
          ....
          root = addtreex(root, word, num, &found);

[TIP]      do { ... } while(0);
      idiom ensures that the code acts like a statement - function call;

[TIP] The reading time for programs is much more than the writing time.
      Make reading easy to do.

[TIP] Each function should do only one task, but do it well.

[STYLE] Each function should hide something.

[TIP] Program testing can be used to show the presence of bugs, but never their
      absence.

[TIP] Most programs spend 90 percent of their time doing 10 percent of their
      instructions. Find this 10 percent, and concentrate your efforts for
      efficiency there.

[TIP] Know your problem. Give precise preconditions and postconditions for each
      function.

[TIP] Keep your algorithms as simple as you can. When in doubt, choose the
      simple way.

[TIP] Consider time and space trade-offs in deciding on your algorithm.

[TIP] Never be afraid to start over. Next time it may be both shorter and
      easier. Starting afresh is usually easier than patching an old program.

[TIP] Be sure you understand your problem completely. If you must change its
      terms, explain exactly what you have done.

[TIP] Always plan to build a prototype and throw it away. You'll do so whether
      you plan to or not.

[TIP] Let your data structure your program. Refine your algorithms and data
      structures at the same time.

[TIP] Once your data are fully structured, your algorithms should almost write
      themselves.

[TIP] A sentinel is an extra item added to one end of a list to ensure that a
      loop will terminate without having to include a separate check.

[TIP] During the traversal of any tree, vertices are added to or deleted from
      the path back to the root in the fashion of a stack. Given any stack,
      conversely, a tree can be drawn to portray the life history of the stack,
      as items are added to or deleted from it.

[TIP] Efforts should be concentrated in the design; never design while coding.
      Time spent producing a careful, thorough design will be more than made
      up for with savings in the later phases of a project. The program
      design should accurately address the needs of the problem. Pseudo-code
      should be used to create high-level outlines of the algorithms. Whenever
      possible, the algorithms should be proven logically and mathematically
      correct.

[STYLE] Programs should be divided into reasonably small modules. The modules
        should first be tested individually and then their interactions should be
        tested. One of the greatest difficulties of writing large programs is that
        their reliability tends to degrade with their length.

[TIP] Programming should be done in a top-down fashion. Large tasks should
      be divided into manageable subtasks. Starting with a broad abstract
      outline of the components of a task should lead to a specification of the
      highest-level functions and control flow. Always begin with the highest
      levels of abstraction and work toward the lowest.

[STYLE] Do not duplicate code; use functions.

[TIP] Close attention should be paid to communication between functions.
      Parameters that are being passed should be appropriate for the role of the
      subfunction. Sometimes it is appropriate to pass more information than
      appears to be needed if that information might be necessary for an
      alternate implementation of the subfunction, or if it is being used to make
      the subfunction more universal. This enables the same function to be
      called in many places and in many different modules.

[TIP] Invest time now for a long-term payoff. Take the time to do things right
      the first time. Do not be afraid to code several alternatives and then
      choose. Do not be afraid to rewrite code that works, but works poorly
      or is unclear.

[STYLE] Take comments and documentation seriously. Without them, programs
        are impossible to read, use, or maintain.

[TIP] Do not work in a vacuum. Discuss design and coding issues with others.
      It is very helpful to read code written by others and have others read
      yours.

[TIP] Isolate input and output in modules specialized for that purpose. Do not
      make them side effects of modules that do other tasks.

[TIP] Above all elsef clarity. Don't be afraid to violate any general principle
      for the sake of clarity.

[STYLE] Avoid global variables. Use functions with parameters instead. When a
        program contains no global variables, one knows that each function
        manipulates only the data that is passed in the form of parameters.

[STYLE] Use abstract data types (ADT).

[TIP] Write generic/polymorphic functions. Although they often take slightly
      longer to write, they are far more likely to be reusable. This way, a "tool
      box" of routines can be developed over time.

[TIP] Programs should be crash-proof. A well-written program should never
      crash. In particular, it should be able to cope with illegal input.

[STYLE] Use assertions. Assertions are statements placed in a program to test
        that conditions that logically should be met have indeed been met. They
        help to track logic errors during development.

[STYLE] Avoid explicit literals. Explicit literals (character, numeric, and string
        values) make programs hard to modify. Use #define'd symbolic names instead.

[STYLE] C provides great freedom. Use it responsibly. Avoid side effects in logical
        tests. Avoid being overly compact at the expense of clarity. Avoid
        following the "convention" of using truncated cryptic names.

[TIP] Think twice before optimizing. Programming time is a precious resource.
      First consider using a different algorithm altogether. If the program must
      be optimized, profile the code to find out where it is spending its time.
      Remember it is always better to improve an algorithm than tune the clarity
      out of code.

[TIP] The effectiveness of a “modularization” is dependent upon the criteria
      used in dividing the system into modules. A timely reminder that it’s not
      simply about having lots of small modules, a large part of the success or
      otherwise of your system depends on how you choose to divide the system
      into modules in the first place.

[TIP] A program has structure: the set of modules in the system, and the
      connections between them.

[TIP] How to decompose program in a modules? First of all do not decompose a
      system into modules on the basis of a flowchart. We propose instead that
      one begins with a list of difficult design decisions or design decisions
      which are likely to change. Each module is then designed to hide such a
      decision from the others as inject this decisions as dependencies.

[TIP] Additional developers speed up a project significantly only after the
      project has been divided into sub-projects in such a way that separate groups
      can work with little interaction (i.e. spending significantly less time in
      inter-group decisions than in intra-group decisions).

[STYLE] Declare your variables as close as possible to the place where you will
        use them.

[STYLE] Don’t use macros to create your own personal programming language.

[STYLE] Don’t put closing braces more than one screen away from the matching
       opening brace.

[TIP] Do not use global variables instead pass a pointer to local variable
      to the next function e.g. root = addtreex(root, word, num, &found);

[LANG] To ensure that result is not negative use unsigned numbers.

[TIP]     for (ptr = head; ptr != NULL; ptr = ptr->next)
      is the standard idiom for walking along a linked list.

[TRICK] Here is you can organize kind of getters:
             typedef struct {
                 node *front;
                 node *rear;
             } queue;
             *define FRONT(Q) ((Q)->front)
             #define REAR(Q)  ((Q)->rear)

[TIP] Do not forget to use strdup(s) when store string e.g.
           np->defun = strdup(s)
      otherwise a lot of pointer will point to the same.

[LANG] Assignment '=' is with very low priority (right to left associations).

[LANG] typedef is not used only for data structures(struct). You can look on it
       as #define, except that since it is interpreted by the compiler, it can
       cope with textual substitutions that are beyond the capabilities of the
       preprocessor. For example you can make code more readable if you alias
       complex function pointer declarations:
           typedef int (*PFI) (char *, char *);
           PFI strcmp, numcmp;    // IDE will help you to go to the alias

[LANG] Unions are similar to structures, except that a variable can hold data
       for only a single member at any given time - same "structure" for
       different types of data. They are implemented by allocating enough space
       for the largest possible member, and overlaying the members.

[TIP] For unions it is up to the programmer to ensure that the same member is
      used to retrieve the data as was used to store the data. A convenient way of
      doing this is to make a structure containing two fields: the union and a "type"
      field to specify which union member is currently stored.

[LANG] The same place regardless of its type this is the purpose of a union -
       a single variable that can legitimately hold any one of several types.

[LANG] A union may only be initialized with a value of the type of its first member.

[TIP] Unions are also sometimes used to implement pseudo-polymorphism in C, by
      giving a structure some tag indicating what type of object it contains, and then
      unioning the possible types together:
           // easier to reuse memory that might be used in different ways
           enum Type { INTS, DOUBLE };
           struct S {
               Type s_type;
               union {
                   int s_ints[2];
                   double s_double;
               };
          };
          ...
          switch(s->s_type) {
              case INTS:    // s->s_ints
              case DOUBLE:  // s->s_double

[TIP] Unions allow data members which are mutually exclusive to share the same memory.
      Following union will take up the space of a single int, rather than 3
      separate int values:
           union {
               int a;
               int b;
               int c;
           } u;

[TIP] Mask usage example:
          enum { KEYWORD=01, EXTERNAL=02, STATIC=04 };
          // turns on the EXTERNAL and STATIC bits in flags
          flags |= EXTERNAL | STATIC;
          // turns them off
          flags &= ~(EXTERNAL | STATIC);
          // is true if both bits are off
          if ((flags & (EXTERNAL | STATIC)) == 0)

[TIP] For reference use: https://en.cppreference.com/w/c

[TIP] When you call malloc(), you specify the amount of memory to allocate. The
      amount of memory actually used is slightly more than this, and includes
      extra information that records (at least) how big the block is. When you
      call free(), it simply looks at the extra information to find out how big
      the block is. That's why you can pass to free() any kind of pointer, even
      (void *).

[TIP] Two goals in developing functions are to make the interfaces as clean as
      possible and to make the source code as readable as possible.

[TIP] Thinks of the types as kind of shaped piece of memory that could be
      chained (pointers as signpost). Path in this maze will give you program
      logic and direct access is vie pointers.

[LANG] It would be more correct to say that stdin, stdout, and stderr are "I/O
       streams" rather than files. But the Unix philosophy, as far as I/O is
       concerned, is "everything is a file".

[LANG] A width or precision of printf may be specified at runtime using *, in
       which case the value is computed by converting the next argument (which
       must be an int). For example, to print at most max characters from a
       string s:
             printf("%.*s", max, s);
