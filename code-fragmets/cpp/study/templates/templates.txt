#_______________________________________________________________________________
#
#   C++ templates notes
#_______________________________________________________________________________
#

"We can solve any problem, by introducing an extra level of indirection."
                                                            Butler Lampson

Templates "parameterize" types the same way that functions "parameterize" values.

With templates you can write code that is independent not only of the values it will be given,
but of the types of those values as well! Just as you use parameter names in functions to represent
the arguments that the caller will pass, you use type names (such as T) in templates to represent
the types that the caller will specify. 

Let's have example template called "Grid". See example code.

    * Templates are best used when the logic to manipulate object is independent
of the objects themselves

    * Place method definitions in a separate header file:
      
      template <typename T>
      class Grid {
         // Class definition omitted
      };

      #include "GridDefinitions.h"

    * Member functions of template class are automatically template functions.

    * Nontype template parameters become part of the type specification of instantiated objects.
      
      Grid<int, 10, 10> and Grid<int, 10, 11> are two different types.

Nontype parameters cannot be objects, or even doubles or floats. They are restricted
only to ints, enums, pointers, and references.
 
    * C++ allows you to templatize individual methods of a class but virtual methods and destructors
      cannot be templatized.

    * Member templates do not replace nontemplate members with the same name.

This rule leads to problems with the copy constructor and operator= because of the
compiler-generated versions. If you write templatized versions of the copy constructor
and operator= and omit nontemplatized versions, the compiler will not
call these new templatized versions for assignments of grids with the same type.
Instead, it will generate a copy constructor and operator= for creating and assigning
two grids of the same type, which will not do what you want!

Thus, you must  keep the old nontemplatized copy constructor and operator= as well.

      // you need both
      Grid<T>& operator=(const Grid<T>& rhs);
      template <typename E>
      Grid<T>& operator=(const Grid<E>& rhs);
    
    * When the template specialization is used, the original template must be visible too.
    * When you specialize a template, you don't "inherit" any code: specializations are not like subclasses.
    * Use inheritance for extending implementations and for polymorphism. Use specialization
      for customizing implementations for particular types.

    * When you write specialized template function do not omit specialized type(common error)
      
      template<>
      int find<char*>(char*& value, char** arr, int size)

      // and when call it
      res = find<char*>(word, arr, 4);

    * Like template class method definitions, function template definitions (not just the prototypes) must be
      available to all source files that use them.

    * It's possible to write both a specialized find() template for char*s and a stand-alone find() function
      for char*s. The compiler always prefers the nontemplate function to a templatized version.

      // tell to take templated explicitly
      res = find<char*>(word, arr, 4);

    * The compiler always chooses the "most specific" version of the function, with nontemplate
      versions being preferred over template versions.
      
    * The syntax of template template parameter is crazy! Specifying a template template parameter is sort of like
      specifying a function pointer parameter in a normal function. Function pointer types include the return type
      and parameter types of a function. The syntax rule for a template template parameter more generically is this:

      template <other params, ..., template <TemplateTypeParams> class ParameterName, other params, ...>

    * You may find it helpful to first define a class using "typedef" and then make a few simple changes that convert
      this class into a template.
    
      // make it work for integers
      typedef int T;
      template <typename T, size_t SIZE>
      ..........

    * Defining the type "element_type" using typedef is a useful technique if you want to be able to retrieve
      the type of a template's argument, for example to declare local variables of that type. For example in "iterator_traits"
      you can define "element_type" without modify the iterator itself.

    * Traits
      Templates enable us to parametrize classes and functions for various types. If we want a fine grain template parametrization,
      that could lead unmanageable number of template parameter. Most template parameters may have default value, and other parameters
      could depend from them. The traits and policy classes are the C++ template tools to manage this kind of dependent type parameters. 

    * Instantiations of templates are unrelated, even if classes for these instantiations are in an inheritance
      relation.

    * Definition and declaration:
      - the template header file stores the template's declaration
      - the template implementation file includes the template header file and defines
        the template using the "export" keyword; for example:

        export template<typename T> void swap(T& x, T& y) {
        .............
        }

    * Do not use CV-Qualified types as template parameters

When you instantiate a template with a CV-qualified [const or volatile] type,
you may inadvertently violate the semantics and usage requirements of the template.

    * Avoiding virtual functions - CRTP

Obviously, you do not have the flexibility of dynamic polymorphism, but this idiom can be very useful
if you want to create some classes with a basic functionality, create the subclasses with a more
specific functionality and use them with no performance cost added.

    template <typename T>
    class base {
      public:
        void implementation(void) {/* default implementation */};

        void interface(void) {
          if ( &base<T>::implementation != &T::implementation ) {
            static_cast<T*>(this)->implementation();
          }
        }
      };
 
    class derived1: public base<derived> {
    };

    class derived2: public base<derived> {
      public:
        void implementation(void) { /* specific implementation */};
    };

In this example of the CRTP, the base class has a default implementation of the interface.
In class derived1, as there is no implementation defined, no implementation gets called.
In class derived2, where there is an implementation defined, it is called. 

Let's say it in other words. The Curiously Recurring Template Pattern (CRTP) involves a template class
that inherits from a base class using itself as a template parameter. Said differently (to perhaps
make that last sentence more clear), it’s when a base class is templated on the type of its derived class.
This provides the fascinating quality that the base class can access the namespace of its derived
class.
The general form of this pattern is as follows:

    template <typename T> class Base;
    class Derived : public Base<Derived>;

The CRTP is essentially just a way to provide compile-time polymorphism. That is, it allows you to
inherit an interface from a base class, but to avoid the overhead of virtual method calls at run time. In
this way, it can be thought of as a “mixin” class, that is, an interface class with implemented methods.

   * If class will be used as template parameter it must have default constructor

   * To have more readable compiler message use STLfilt (http://www.bdsoft.com/tools/stlfilt.html)
