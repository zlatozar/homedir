#_______________________________________________________________________________
#
#   How to create API classes
#_______________________________________________________________________________
#

What is good design?

   1. Good design is innovative
   2. Good design makes a product useful
   3. Good design is aesthetic
   4. Good design makes a product understandable
   5. Good design is unobtrusive
   6. Good design is honest
   7. Good design is long-lasting
   8. Good design is thorough down to the last detail
   9. Good design is environmentally friendly
  10. Good design is as little design as possible

Three Laws of Interfaces:

   1. An interface’s implementation shall do what its methods say it does.
   2. An interface’s implementation shall do no harm.
   3. If an interface’s implementation is unable to perform its responsibilities, it shall notify its caller.

How to make good API design?

1. All programmers are API designers. Good programs are modular, and intermodular boundaries define APIs.
   Good modules get reused.

2. APIs can be among your greatest assets or liabilities. Good APIs create long-term customers;
   bad ones create long-term support nightmares.

3. Public APIs, like diamonds, are forever. You have one chance to get it right so give it your best.

4. APIs should be easy to use and hard to misuse. It should be easy to do simple things;
   possible to do complex things; and impossible, or at least difficult, to do wrong things.

5. APIs should be self-documenting: It should rarely require documentation to read code written to a good API. In fact,
   it should rarely require documentation to write it.

6. When designing an API, first gather requirements—with a healthy degree of skepticism. People often provide solutions;
   it's your job to ferret out the underlying problems and find the best solutions.

7. Structure requirements as use-cases: they are the yardstick against which you'll measure your API.

8. Early drafts of APIs should be short, typically one page with class and method signatures and one-line descriptions.
   This makes it easy to restructure the API when you don't get it right the first time.

9. Code the use-cases against your API before you implement it, even before you specify it properly.
   This will save you from implementing, or even specifying, a fundamentally broken API.

10. Maintain the code for uses-cases as the API evolves. Not only will this protect you from rude surprises,
    but the resulting code will  become the examples for the API, the basis for tutorials and tests.

11. Example code should be exemplary. If an API is used widely, its examples will be the archetypes for thousands of programs.
    Any mistakes will come back to haunt you a thousand fold.

12. You can't please everyone so aim to displease everyone equally. Most APIs are overconstrained.

13. Expect API-design mistakes due to failures of imagination. You can't reasonably hope to imagine everything that
    everyone will do with an API, or how it will interact with every other part of a system.

14. API design is not a solitary activity. Show your design to as many people as you can, and take their feedback seriously.
    Possibilities that elude your imagination may be clear to others.

15. Avoid fixed limits on input sizes. They limit usefulness and hasten obsolescence.

16. Names matter. Strive for intelligibility, consistency, and symmetry. Every API is a little language, and people must learn
    to read and write it. If you get an API right, code will read like prose.

17. If it's hard to find good names, go back to the drawing board. Don't be afraid to split or merge an API,
    or embed it in a more  general setting. If names start falling into place, you're on the right track.

18. When in doubt, leave it out. If there is a fundamental theorem of API design, this is it.
    It applies equally to functionality, classes, methods, and parameters.
    Every facet of an API should be as small as possible, but no smaller.
    You can always add things later, but you can't take them away. Minimizing conceptual weight
    is more important than class- or method-count.

19. Keep APIs free of implementations details. They confuse users and inhibit the flexibility to evolve.
    It isn't always obvious what's an implementation detail: Be wary of overspecification.

20. Minimize mutability. Immutable objects are simple, thread-safe, and freely sharable.

21. Documentation matters. No matter how good an API, it won't get used without good documentation.
    Document every exported API element: every class, method, field, and parameter.

22. Consider the performance consequences of API design decisions, but don't warp an API to achieve performance gains.
    Luckily, good APIs typically lend themselves to fast implementations.

23. When in Rome, do as the Romans do. APIs must coexist peacefully with the platform, so do what is customary.
    It is almost always wrong to "transliterate" an API from one platform to another.

24. Minimize accessibility; when in doubt, make it private. This simplifies APIs and reduces coupling.

25. Subclass only if you can say with a straight face that every instance of the subclass is an instance of the superclass.
    Exposed classes should never subclass just to reuse implementation code.

26. Design and document for inheritance or else prohibit it. This documentation takes the form of selfuse patterns:
    how methods in a class use one another. Without it, safe subclassing is impossible.

27. Don't make the client do anything the library could do. Violating this rule leads to boilerplate code in the client,
    which is annoying and error-prone.

28. Obey the principle of least astonishment. Every method should do the least surprising thing it could, given its name.
    If a method doesn't do what users think it will, bugs will result.

29. Fail fast. The sooner you report a bug, the less damage it will do. Compile-time is best. If you must fail at run-time,
    do it as soon as possible.

30. Provide programmatic access to all data available in string form. Otherwise, programmers will be forced to parse strings,
    which is painful. Worse, the string forms will turn into de facto APIs.

31. Overload with care. If the behaviors of two methods differ, it's better to give them different names.

32. Use the right data type for the job. For example, don't use string if there is a more appropriate type.

33. Use consistent parameter ordering across methods. Otherwise, programmers will get it backwards.

34. Avoid long parameter lists, especially those with multiple consecutive parameters of the same type.

35. Avoid return values that demand exceptional processing. Clients will forget to write the specialcase code, leading to bugs.
    For example, return zero-length arrays or collections rather than nulls.

36. Throw exceptions only to indicate exceptional conditions. Otherwise, clients will be forced to use exceptions
    for normal flow control, leading to programs that are hard to read, buggy, or slow.

37. Throw unchecked exceptions unless clients can realistically recover from the failure.

38. API design is an art, not a science. Strive for beauty, and trust your gut.
    Do not adhere slavishly to the above heuristics, but violate them only infrequently and with good reason.

#_______________________________________________________________________________
#
#   Patterns and C++ idioms
#_______________________________________________________________________________
#


1. PIMPL

TIP: When using the pimpl idiom use a private nested implementation class. Only use a public nested Impl class
(or a public non-nested class) if other classes or free functions in the .cpp must access Impl members.

A C++ compiler will create a copy constructor and assignment operator for your class if you don’t
explicitly define them. However, these default constructors will only perform a shallow copy of your
object. This is bad for pimpled classes because it means that if a client copies your object then both
objects will point to the same implementation object, Impl. However, both objects will attempt to
delete this same Impl object in their destructors, which will most likely lead to a crash. Two options
for dealing with this are as follow.

-- Make your class uncopyable.
Example:
   
#include <string>
class AutoTimer
{
  public:
    explicit AutoTimer(const std::string &name);
    AutoTimer();
  private:
    // Make this object be non-copyable
    AutoTimer(const AutoTimer&);
    const AutoTimer &operator=(const AutoTimer&);

    class Impl;
    Impl *_impl;
};

-- Explicitly define the copy semantics

1.1 Pimpl and Smart Pointers

One of the inconvenient and error-prone aspects of pimpl is the need to allocate and deallocate the
implementation object. Every now and then you may forget to delete the object in your destructor or
you may introduce bugs by accessing the Impl object before you’ve allocated it or after you’ve
destroyed it. As a convention, you should therefore ensure that the very first thing your constructor
does is to allocate the Impl object (preferably via its initialization list), and the very last thing your
destructor does is to delete it.

#include <boost/scoped_ptr.hpp>
#include <string>
class AutoTimer
{
  public:
    explicit AutoTimer(const std::string &name);
    AutoTimer();
  private:
    class Impl;
    // non-copyable by definition
    boost::scoped_ptr<Impl> _impl;
};

Alternatively, you could use a boost::shared_ptr, which would allow the object to be copied
without incurring the double delete issues identified earlier. Using either a shared or a scoped pointer
means that the Impl object will be freed automatically when the AutoTimer object is destroyed: you no longer
need to delete it explicitly in the destructor.

2. Singleton

-- Enforces that only one instance of the class can be created.
-- Provides control over the allocation and destruction of the object.
-- Allows support for thread-safe access to the object’s global state.
-- Avoids polluting the global namespace.

TIP: Declare the constructor, destructor, copy constructor, and assignment operator to be private (or protected) to
enforce the Singleton property.

TIP: Creating a thread-safe Singleton in C++ is hard. Consider initializing it with a static constructor or an API
initialization function.

The Monostate pattern allows multiple instances of a class to be created where all of those
instances use the same static data. For instance, here’s a simple case of the Monostate pattern:

// monostate.h
class Monostate
{
  public:
    int getTheAnswer() const { return sAnswer; }
  private:
     static int sAnswer;
};

// monostate.cpp
int Monostate::sAnswer = 42;

In this example, you can create multiple instances of the Monostate class, but all calls to the
getTheAnswer() method will return the same result because all instances share the same static variable
sAnswer. You could also hide the declaration of the static variable from the header completely
by just declaring it as a file-scope static variable in monostate.cpp instead of a private class static
variable. Because static members do not contribute to the per instance size of a class, doing this will
have no physical impact on the API, other than to hide implementation details from the header.

Some benefits of the Monostate pattern are that it:

- Allows multiple instances to be created.
- Offers transparent usage because no special getInstance() method is needed.
- Exhibits well-defined creation and destruction semantics using static variables.

Singleton enforces the structure of singularity by only allowing one instance to be created, whereas
Monostate enforces the behavior of singularity by sharing the same data for all instances.

TIP: Consider using Monostate instead of Singleton if you don’t need lazy initialization of global data or if you want the
singular nature of the class to be transparent.

3. Factory Methods

In essence, a factory method is a generalization of a constructor. Constructors in C++ have several
limitations, such as the following.

- No return result.
- Constrained naming.
- Statically bound creation.

When constructing an object, you must specify the name of a concrete class that is known at compile time,
for example, you might write:
Foo *f = new Foo(),

where Foo is a specific type that must be known by the compiler. There is no concept of dynamic
binding at run time for constructors in C++.

- No virtual constructors.

In contrast, factory methods circumvent all of these limitations. At a basic level, a factory
method is simply a normal method call that can return an instance of a class. However, they are
often used in combination with inheritance, where a derived class can override the factory method
and return an instance of that derived class. It’s also very common and useful to implement
factories using abstract base classes (pure virtual classes).

TIP: To decouple the concrete derived classes from the factory method and to allow new derived classes
to be added at run time, you can update the factory class to maintain a map that associates type
names to object creation callbacks. You can then allow new derived classes to be registered and unregistered
using a couple of new method calls.

4. Function parameters

Use of the const keyword can also be used to indicate whether you intend for a parameter to be an
input or an output parameter, that is, a parameter used to pass some value into a method or a parameter
used to receive some result.

5. Pointer versus Reference Parameters

Prefer the use of const references over pointers for input parameters where feasible. For output parameters,
consider using pointers over non-const references to indicate explicitly to the client that they may be modified.

6. Declaring Constants

Declare global scope constants with extern or declare constants in classes as static const. Then define the value of
the constant in the .cpp file. This reduces the size of object files for modules that include your headers. Even
better, hide these constants behind a function call.
